#### 基本块的划分

###### 注意事项

for控制流：

<img src="C:\Users\像我这样优秀的人\AppData\Roaming\Typora\typora-user-images\1608186498415.png" alt="1608186498415" style="zoom:50%;" />

###### 已发现的bug

1. global_block未加入基本块的划分
2. 不能按照整个程序划分基本块，要按照函数组织
3. （笔误）基本块划分不完备

###### 更改方向



#### 添加控制流

###### 一个例子

<img src="C:\Users\像我这样优秀的人\AppData\Roaming\Typora\typora-user-images\1608187867052.png" alt="1608187867052" style="zoom:80%;" />

###### 注意事项

1. 最后一条exit语句没有后继

###### 已发现bug

1.最后一条语句为跳转语句的基本块在添加其后继时寻找出错（笔误）

2.b类语句与j的跳转label所在的操作数不同（此时只考虑b类与j跳转语句，若加了jal需要多于考虑）

#### 活跃变量分析

###### 一个例子

| block_num | 前驱 | 后继 | def    | use     |
| --------- | ---- | ---- | ------ | ------- |
| 0         | \    | 1    | n      |         |
| 1         | 0    | 2    | a,x,y  |         |
| 2         | 1    | 3    | temp,i |         |
| 3         | 2,4  | 4,5  |        | i       |
| 4         | 3    | 3    |        | i，temp |
| 5         | 3    | 6    | i      |         |
| 6         | 5,7  | 7,8  |        | i       |
| 7         | 6    | 6    | temp   | i       |
| 8         | 6    | \    |        |         |



| block_num | in     | out    |
| --------- | ------ | ------ |
| 0         | \      | \      |
| 1         | \      | \      |
| 2         | \      | i,temp |
| 3         | i,temp | i,temp |
| 4         | i,temp | i,temp |
| 5         | \      | i      |
| 6         | i      | i      |
| 7         | i      | i      |
| 8         | \      | \      |

一些小约束：

1. 函数传的参数应该相当于有初始化定义，（不过现阶段我们好像是从内存中取，即算为use）问题：参数究竟是拿a0~a3分配还是通过寄存器池分配?如果拿a0~a3还用变量分析么?毕竟所属的寄存器池不同的话用变量分析好像没用吧...，还有注意a0在这里被定义成了返还结果所需寄存器

   我现在的想法：不对值参数表进行def分析，意思是参数不可能获得寄存器。

   **bug：!!! 不对参数做定义处理会跑出作用域!**

2. 只考虑全局变量、局部变量的非数组类型的变量的分配

3. scanf也应相当于定义

4. 全局变量**不能够**参与寄存器的分配，虽然现在排除了数组变量，但**未进行测试**，有可能出错，将导致数组变量定义无法追溯。

###### 已发现的bug

1. 由于语法规定，在分析同一条四元式的时候，use的优先级比def高，所以四元式的分析应当先分析use，再分析def

2. 判断是否def的条件只有addressbasetype

3. b类与math类所使用的操作数位置不同

4. **无初始化变量定义究竟有没有var???**

   解决办法是：增加初始化0的操作，加入四元式中
   
5. use中忘添加printf

6. （笔误）恢复寄存器忘换行

#### 内联活跃变量分析与冲突图建立

内联活跃变量分析没什么大问题，该检查冲突图了

###### 一个例子

<img src="C:\Users\像我这样优秀的人\AppData\Roaming\Typora\typora-user-images\1608210141428.png" alt="1608210141428" style="zoom:50%;" />

<img src="C:\Users\像我这样优秀的人\AppData\Roaming\Typora\typora-user-images\1608210154334.png" alt="1608210154334" style="zoom:50%;" />

###### 已发现bug

1. （笔误）第一次创建set后忘记添加结点

2. （语法）map不提供更改功能，必须先erase，再insert

3. 没有冲突的变量也应加到冲突图里，即所有变量都要在冲突图，不管有没有边。

   解决方法是：定义时将所有定义点放入冲突图，并添加空冲突集

4. 给参数没有算到使用。再检查一下use，吃了两次亏了

#### 最后

###### 已发现bug

1. 调用函数要保护所有寄存器，出函数要回退所有寄存器

#### 性能还比较低下的地方

1. 表达式临时变量必须先存储在取出，明明可以直接用，但是却平白无故多出两条存取指令

2. 表达式的乘法



#### 性能比较

第一次：

| testfile | rank |
| -------- | ---- |
| 1        | 151  |
|          |      |
|          |      |
|          |      |
|          |      |
|          |      |
|          |      |
|          |      |

第二次：

| testfile | rank |
| -------- | ---- |
| 1        | 151  |
|          |      |
|          |      |
|          |      |
|          |      |
|          |      |
|          |      |
|          |      |

----

### 临时寄存器的分配

----

###### 引言-基本思路

1. 对全局寄存器的分配与临时寄存器做出区分标志（操作数加reg_type）（√）
2. 罗列出所有可能用到临时寄存器的情况
3. 建立映射数组，并扫描中间代码，分配临时寄存器
4. 调用函数时对临时寄存器进行保护，并注意存取与取出的过程

##### 临时寄存器使用情况

临时变量是在计算过程中产生的，计算过程所用的指令包括`+ - * /`。

上述的计算指令大概率出现在表达式中，接下来先对表达式做介绍：

###### 1.表达式中的临时变量

且每个阶段的最后的临时变量一定是外部显示调用表达式的结果（不包括因子-表达式的嵌套）。表达式可能出现的地方罗列如下：

<img src="C:\Users\像我这样优秀的人\AppData\Roaming\Typora\typora-user-images\1608351075997.png" alt="1608351075997" style="zoom:80%;" />

表达式临时变量的消去分别在：

赋值语句assign右边使用、b类条件跳转语句的左右侧、循环语句for变量初始化时的赋值语句、情况语句、swicth b类语句的左右侧、值参数表O_giveparameter四元式中、printf语句中、返回语句savebackvalue中、数组的下标中。

其中：

1. 注意数组就算用临时寄存器也有可能出现非直接地址的情况。但也只会使用一次
2. 情况语句中switch的表达式需要用到多次。**在switch语句里生成一个存入地址指令即可。**

###### 2.非表达式中的临时变量

上述计算指令还有可能出现在表达式之外，例如：

<img src="C:\Users\像我这样优秀的人\AppData\Roaming\Typora\typora-user-images\1608352207938.png" alt="1608352207938" style="zoom:80%;" />

不过也遵循上述的规律，在assign与运算四元式中。



##### 如何展开工作

将BlockList从上到下扫描：

1. 对每个“加减乘除”指令的运算结果（即item1）标识分配临时寄存器。
2. 对每个可以使用临时寄存器的指令进行使用并消除处理。
3. 无了。
4. 形成mips，判断， 如果使用寄存器，并且使用的类型是t，则输出相应t寄存器

##### 注意事项

1. 一定要主要正确的产生与正确的调用，哪一个出错都会导致出大错。
2. switch中表达式的保护，已完成。
3. 函数调用寄存器的保护，完成。
4. 数组的取有问题。数组参与消去运算
5. 换个思路，让非直接的数组还是采用原来的存取操作。保守起见，数组下标表达式产生一条存放指令



##### 已发现的bug

1. return忘记写temp的情况了

































